syntax = "proto3";

package executor.v1;

option go_package = "executor/v1;executor";

enum ExecutionStatus {
  UNKNOWN = 0; // 未知状态
  RUNNING = 1; // 正在执行
  FAILED_RETRYABLE = 2; // 可重试失败
  FAILED_RESCHEDULABLE = 3; // 可重调度失败
  FAILED = 4; // 不可重试失败
  SUCCESS = 5; // 执行成功
}

message ExecutionState {
  int64 id = 1;
  int64 task_id = 2;
  string task_name = 3;
  // 中断时刻执行节点的执行进度
  ExecutionStatus status = 4; // RUNNING，FAILED_RETRYABLE，FAILED，SUCCESS
  // 0-100 的数字。代表进度
  // RUNNING 状态才有意义
  int32 running_progress = 5;
  // 执行节点请求调度节点执行重调度，
  // 调度节点无需调interrupt，调度节点可以直接重调度，因为此时执行节点必然已经停止了
  bool request_reschedule = 6;
  // 重调度（执行节点主动提出）或者中断后的恢复参数（调度节点主动要求）
  // 用于重调度或中断恢复重新调度的参数
  // 比如：调用 A 节点上，中断任务
  // A 节点返回 offset = 10000, limit = 100
  // 你后续重调度到 B 节点上，
  // 传递给 B 节点的 ExecuteRequest 的 params 里面就包含 offset, limit
  map<string, string> rescheduled_params = 7;
  // 执行节点的 nodeID，用于记录是哪个节点处理了任务
  string executor_node_id = 8;
}

// ExecutorService 执行节点需要实现的接口，以便调度节点可以通知执行节点执行任务、中断任务及查询任务执行状态。
service ExecutorService {
  // 执行一个任务
  rpc Execute(ExecuteRequest) returns (ExecuteResponse);
  // 中断一个正在执行的任务
  rpc Interrupt(InterruptRequest) returns (InterruptResponse);
  // 查询一个任务的状态（用于轮询模式）
  rpc Query(QueryRequest) returns (QueryResponse);
  // 查询业务方任务总数量
  rpc Prepare(PrepareRequest) returns (PrepareResponse);
}

message ExecuteRequest {
  int64 eid = 1; // execution id
  int64 task_id = 2;
  string task_name = 3;
  string task_handler_name = 4;
  // 这里有两部分
  // 1 一部分是通过管理后台，业务方自己搞的参数
  // 2. 另外一部分是我们调度用的，比如说 offset, limit
  // 即包含了业务参数和调度参数 (e.g., offset, limit)
  map<string, string> params = 5;
}

message ExecuteResponse {
  ExecutionState execution_state = 1;
}

message InterruptRequest {
  int64 eid = 1;
}

message InterruptResponse {
  bool success = 1; // 是否成功中断
  ExecutionState execution_state = 3;
}

message QueryRequest {
  int64 eid = 1;
}

message QueryResponse {
  ExecutionState execution_state = 1;
}

message PrepareRequest {
  int64 eid = 1; // execution id
  int64 task_id = 2;
  string task_name = 3;
  // 这里有两部分
  // 1 一部分是通过管理后台，业务方自己搞的参数
  // 2. 另外一部分是我们调度用的，比如说 offset, limit
  // 即包含了业务参数和调度参数 (e.g., offset, limit)
  map<string, string> params = 4;
}

message PrepareResponse {
  map<string, string> params = 1;
}
